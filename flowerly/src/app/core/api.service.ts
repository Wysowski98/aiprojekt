/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ApiClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:44362";
  }

  flower_GetAll(): Observable<Flower[]> {
    let url_ = this.baseUrl + "/api/Flower";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processFlower_GetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processFlower_GetAll(<any>response_);
        } catch (e) {
          return <Observable<Flower[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<Flower[]>><any>_observableThrow(response_);
    }));
  }

  protected processFlower_GetAll(response: HttpResponseBase): Observable<Flower[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <Flower[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Flower[]>(<any>null);
  }

  flower_AddNewFlowerType(flowersDto: FlowerDto): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/api/Flower/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(flowersDto);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processFlower_AddNewFlowerType(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processFlower_AddNewFlowerType(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processFlower_AddNewFlowerType(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }

  myFlowers_GetMyFlowers(id: string | null | undefined): Observable<MyFlowers[]> {
    let url_ = this.baseUrl + "/api/MyFlowers?";
    if (id !== undefined && id !== null)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processMyFlowers_GetMyFlowers(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processMyFlowers_GetMyFlowers(<any>response_);
        } catch (e) {
          return <Observable<MyFlowers[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<MyFlowers[]>><any>_observableThrow(response_);
    }));
  }

  protected processMyFlowers_GetMyFlowers(response: HttpResponseBase): Observable<MyFlowers[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <MyFlowers[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<MyFlowers[]>(<any>null);
  }

  myFlowers_GetMyFlowersIrrigationDates(userId: string | null | undefined): Observable<IrrigationDates[]> {
    let url_ = this.baseUrl + "/api/MyFlowers/dates?";
    if (userId !== undefined && userId !== null)
      url_ += "userId=" + encodeURIComponent("" + userId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processMyFlowers_GetMyFlowersIrrigationDates(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processMyFlowers_GetMyFlowersIrrigationDates(<any>response_);
        } catch (e) {
          return <Observable<IrrigationDates[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<IrrigationDates[]>><any>_observableThrow(response_);
    }));
  }

  protected processMyFlowers_GetMyFlowersIrrigationDates(response: HttpResponseBase): Observable<IrrigationDates[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <IrrigationDates[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<IrrigationDates[]>(<any>null);
  }

  myFlowers_GetMyFlowersIrrigationHistory(flowerId: number | undefined): Observable<IrrigationDates[]> {
    let url_ = this.baseUrl + "/api/MyFlowers/history?";
    if (flowerId === null)
      throw new Error("The parameter 'flowerId' cannot be null.");
    else if (flowerId !== undefined)
      url_ += "flowerId=" + encodeURIComponent("" + flowerId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processMyFlowers_GetMyFlowersIrrigationHistory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processMyFlowers_GetMyFlowersIrrigationHistory(<any>response_);
        } catch (e) {
          return <Observable<IrrigationDates[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<IrrigationDates[]>><any>_observableThrow(response_);
    }));
  }

  protected processMyFlowers_GetMyFlowersIrrigationHistory(response: HttpResponseBase): Observable<IrrigationDates[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <IrrigationDates[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<IrrigationDates[]>(<any>null);
  }

  myFlowers_AddNewFlower(flowersDto: MyFlowersDto): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/api/MyFlowers/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(flowersDto);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processMyFlowers_AddNewFlower(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processMyFlowers_AddNewFlower(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processMyFlowers_AddNewFlower(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }

  myFlowers_UpdateFlower(flowersDto: MyFlowersUpdateCommand): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/api/MyFlowers/update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(flowersDto);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processMyFlowers_UpdateFlower(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processMyFlowers_UpdateFlower(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processMyFlowers_UpdateFlower(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }

  myFlowers_DeleteFlower(myFlowersId: number | undefined): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/api/MyFlowers/delete?";
    if (myFlowersId === null)
      throw new Error("The parameter 'myFlowersId' cannot be null.");
    else if (myFlowersId !== undefined)
      url_ += "myFlowersId=" + encodeURIComponent("" + myFlowersId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processMyFlowers_DeleteFlower(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processMyFlowers_DeleteFlower(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processMyFlowers_DeleteFlower(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }

  myFlowers_AddNewFlower2(code: string | null, history: number): Observable<FileResponse | null> {
    let url_ = this.baseUrl + "/api/MyFlowers/emailConfirmation/{code}/{history}";
    if (code === undefined || code === null)
      throw new Error("The parameter 'code' must be defined.");
    url_ = url_.replace("{code}", encodeURIComponent("" + code));
    if (history === undefined || history === null)
      throw new Error("The parameter 'history' must be defined.");
    url_ = url_.replace("{history}", encodeURIComponent("" + history));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processMyFlowers_AddNewFlower2(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processMyFlowers_AddNewFlower2(<any>response_);
        } catch (e) {
          return <Observable<FileResponse | null>><any>_observableThrow(e);
        }
      } else
        return <Observable<FileResponse | null>><any>_observableThrow(response_);
    }));
  }

  protected processMyFlowers_AddNewFlower2(response: HttpResponseBase): Observable<FileResponse | null> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
      const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<FileResponse | null>(<any>null);
  }

  statisctics_GetMyIrrigationHistory(id: string | null | undefined): Observable<IrrigationHistory[]> {
    let url_ = this.baseUrl + "/api/Statisctics/chart?";
    if (id !== undefined && id !== null)
      url_ += "id=" + encodeURIComponent("" + id) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processStatisctics_GetMyIrrigationHistory(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStatisctics_GetMyIrrigationHistory(<any>response_);
        } catch (e) {
          return <Observable<IrrigationHistory[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<IrrigationHistory[]>><any>_observableThrow(response_);
    }));
  }

  protected processStatisctics_GetMyIrrigationHistory(response: HttpResponseBase): Observable<IrrigationHistory[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <IrrigationHistory[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<IrrigationHistory[]>(<any>null);
  }

  statisctics_GetDataForProgress(myFlowerId: number | undefined): Observable<Date[]> {
    let url_ = this.baseUrl + "/api/Statisctics/progreess?";
    if (myFlowerId === null)
      throw new Error("The parameter 'myFlowerId' cannot be null.");
    else if (myFlowerId !== undefined)
      url_ += "myFlowerId=" + encodeURIComponent("" + myFlowerId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processStatisctics_GetDataForProgress(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processStatisctics_GetDataForProgress(<any>response_);
        } catch (e) {
          return <Observable<Date[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<Date[]>><any>_observableThrow(response_);
    }));
  }

  protected processStatisctics_GetDataForProgress(response: HttpResponseBase): Observable<Date[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        result200 = _responseText === "" ? null : <Date[]>JSON.parse(_responseText, this.jsonParseReviver);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Date[]>(<any>null);
  }

  user_UpsertUser(user: UserDto): Observable<void> {
    let url_ = this.baseUrl + "/api/User";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(user);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
      return this.processUser_UpsertUser(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUser_UpsertUser(<any>response_);
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processUser_UpsertUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

export interface Flower {
  id: number;
  name?: string | undefined;
  species?: string | undefined;
  nationality?: string | undefined;
  imageUrl?: string | undefined;
  irrigationPerWeek: number;
  waterAmount: WaterAmountEnum;
}

export enum WaterAmountEnum {
  Small = 0,
  Medium = 1,
  High = 2,
}

export interface FlowerDto {
  name?: string | undefined;
  species?: string | undefined;
  nationality?: string | undefined;
  imageUrl?: string | undefined;
  irrigationPerWeek: number;
  waterAmount: WaterAmountEnum;
}

export interface MyFlowers {
  id: number;
  flower?: Flower | undefined;
  user?: User | undefined;
  irrigationDates?: IrrigationDates[] | undefined;
}

export interface User {
  id: number;
  uid?: string | undefined;
  displayName?: string | undefined;
  email?: string | undefined;
  flowers?: MyFlowers[] | undefined;
}

export interface IrrigationDates {
  id: number;
  dayNumber: number;
  dayName?: string | undefined;
  myFlowers?: MyFlowers | undefined;
  scheduledJobId?: string | undefined;
  isCompleted: boolean;
  history?: IrrigationHistory[] | undefined;
}

export interface IrrigationHistory {
  id: number;
  myFlower?: MyFlowers | undefined;
  user?: User | undefined;
  irrigationDate: Date;
  isCompleted: boolean;
}

export interface MyFlowersDto {
  flowerId: number;
  userId?: string | undefined;
}

export interface MyFlowersUpdateCommand {
  flowerId: number;
  userId?: string | undefined;
  dates?: IrrigationDates | undefined;
}

export interface UserDto {
  uid?: string | undefined;
  displayName?: string | undefined;
  email?: string | undefined;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
